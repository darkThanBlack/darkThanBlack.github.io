# Modularize

简要记录模块化过程中个人思路和要点。

> Created: 2022/06/26



## 哲学

绝对的论断默认前提是尚未实现任何模块化，否则展开永远讲不完。下同。



强业务相关，随业务总量和人员规模演进，基于团队实力选型。

极度依赖主导者能力和团队水准，讨论前先确认好业务场景，前提和背景，否则鸡同鸭讲。

综上，具体实现并无定法，方案也往往无法套用，有起点无终点。

同理，缺乏业务和协作经验则注定无法理解，不看经历就在面试里问是在浪费时间。



技术演进的根本目的是提升业务效率，不结合业务的技术注定失败；

最影响效率的是代码编译速度，如果你认为不是，那么你不需要参与讨论；

编译加速的核心手段是静态化，任何不实现静态化的加速方案都不需要去考虑；

静态化后的代码无法被修改，所以需要区分出被修改的代码，和不被修改的代码。

在对代码进行区分过后，必然形成相对独立的多份代码，有人将这些代码称为模块，将区分的手段称为模块化。

静态化的代码越多，编译速度越快；静态化的代码越少，编译速度越慢。好的方案需要使可静态化的代码尽可能多。

代码之间的联系越多，修改时涉及到的代码也就越多，可静态化的代码就越少，编译速度越慢。好的方案需要使模块代码之间的关联尽可能少。

静态化手段本身具有成本。好的方案需要尽可能降低使用成本。



## 语言特性

先考虑手动制作一个最通用的静态库。lipo 的合并命令使用非常简单，导致网上充斥着大量的垃圾教程。



纯 ObjC / 纯 Swift / ObjC - Swift 混编 / *.a - *.framework 重新封装 / *.bundle 处理 都必须考虑到。如果新业务涉及到的时候需要重新制作静态库，那就是你的问题。

要注意混编相关的多种场景：静态库本身是纯 ObjC / 纯 Swift，但会被另一种代码调用；静态库内部的代码混编了 ObjC 和 Swift。

*.bundle 可能需要单独处理，做完后一定要测一下。需要提供快速验证静态库调用本身 *.bundle 是否成功的手段。现在还可能有 *.docC。



## 选型

我现在敢说 Swift 最大的痛点就是静态库支持。基于较低版本 Swift 制作的静态库无法在任何更高版本的 Swift 环境中运行。



#### *.xcFramework

缺失关键特性。不可接受。不可用。



